###############################################################################
#
# IAR C/C++ Compiler V10.40.1.7397 for 8051               01/May/2021  16:40:16
# Copyright 2004-2021 IAR Systems AB.
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\Source\znp_app.c
#    Command line       =  
#        -f C:\Users\asus\AppData\Local\Temp\EW41FC.tmp ("E:\Texas
#        Instruments\Z-Stack 3.0.2\Projects\zstack\ZNP\Source\znp_app.c" -D
#        BDB_FINDING_BINDING_CAPABILITY_ENABLED=0 -D TC_LINKKEY_JOIN -D
#        HAL_UART_DMA_RX_MAX=128 -D MAXMEMHEAP=2765 -D NWK_MAX_DEVICE_LIST=10
#        -D ZDSECMGR_TC_DEVICE_MAX=30 -D DISABLE_GREENPOWER_BASIC_PROXY -D
#        FEATURE_SYSTEM_STATS -D MT_GP_CB_FUNC -D ASSERT_RESET -D FAKE_CRC_SHDW
#        -lC "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\CC2530-ZNP-with-SBL\List" -lA
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\CC2530-ZNP-with-SBL\List"
#        --diag_suppress Pe001,Pa010 -o "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\CC2530-ZNP-with-SBL\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -f "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
#        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR | DEVICE_BUILD_ROUTER
#        | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL -DZNP_RUN_WDOG=FALSE
#        -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO -DZIGBEE_FRAGMENTATION
#        -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE -DSAPI_CB_FUNC=FALSE
#        -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT -DNUM_DISC_ATTEMPTS=0
#        -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC -DMT_SAPI_FUNC
#        -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC -DMT_ZDO_MGMT
#        -DMT_ZDO_EXTENSIONS -DMT_GP_CB_FUNC -DMT_APP_FUNC -DMT_APP_CNF_FUNC
#        -DZNP_ALT) -f "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg" -I
#        "E:\Texas Instruments\Z-Stack 3.0.2\Projects\zstack\ZNP\CC253x\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\Source\" -I "E:\Texas
#        Instruments\Z-Stack 3.0.2\Projects\zstack\ZNP\CC253x\..\Source\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I "E:\Texas
#        Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\Utilities\BootLoad\Source\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I "E:\Texas
#        Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530ZNP\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary163\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary283\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\gp\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\bdb\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
#        -I "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\" -I
#        "E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  English_USA.1252
#    List file          =  
#        E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\CC2530-ZNP-with-SBL\List\znp_app.lst
#    Object file        =  
#        E:\Texas Instruments\Z-Stack
#        3.0.2\Projects\zstack\ZNP\CC253x\CC2530-ZNP-with-SBL\Obj\znp_app.r51
#
###############################################################################

E:\Texas Instruments\Z-Stack 3.0.2\Projects\zstack\ZNP\Source\znp_app.c
      1          /**************************************************************************************************
      2            Filename:       znp_app.c
      3            Revised:        $Date: 2014-11-24 18:26:24 -0800 (Mon, 24 Nov 2014) $
      4            Revision:       $Revision: 41234 $
      5          
      6            Description:    This file is the Application implementation for the ZNP.
      7          
      8          
      9            Copyright 2009-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_board_cfg.h"
     46          #include "mac_radio_defs.h"
     47          #include "MT.h"
     48          #include "MT_AF.h"
     49          #include "MT_SYS.h"
     50          #include "MT_UART.h"
     51          #include "MT_UTIL.h"
     52          #include "MT_ZDO.h"
     53          #if defined MT_ZNP_FUNC
     54          #include "MT_ZNP.h"
     55          #endif
     56          #include "OSAL.h"
     57          #include "OSAL_Nv.h"
     58          #if defined POWER_SAVING || defined CC2531ZNP
     59          #include "OSAL_PwrMgr.h"
     60          #endif
     61          #include "ZComDef.h"
     62          #include "ZMAC.h"
     63          #include "znp_app.h"
     64          #include "znp_spi.h"
     65          
     66          #if defined ( TC_LINKKEY_JOIN ) || defined ( ZCL_KEY_ESTABLISH )
     67            #include "zcl.h"
     68          #endif
     69          
     70          /* ------------------------------------------------------------------------------------------------
     71           *                                           Local Functions
     72           * ------------------------------------------------------------------------------------------------
     73           */
     74          
     75          static void npInit(void);
     76          static void npInitNV(void);
     77          
     78          #if defined MT_ZNP_FUNC
     79          static void npBasicRsp(void);
     80          #endif
     81          
     82          static void npUartCback(uint8 port, uint8 event);
     83          static void npUartTxReady(void);
     84          static uint8* npMtUartAlloc(uint8 cmd0, uint8 len);
     85          static void npMtUartSend(uint8 *pBuf);
     86          
     87          #if !defined CC2531ZNP
     88          static uint8* npMtSpiAlloc(uint8 cmd0, uint8 len);
     89          static void npMtSpiSend(uint8 *pBuf);
     90          uint8* npSpiPollCallback(void);
     91          bool npSpiReadyCallback(void);
     92          #endif
     93          
     94          /* ------------------------------------------------------------------------------------------------
     95           *                                           Local Variables
     96           * ------------------------------------------------------------------------------------------------
     97           */
     98          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     99          static osal_msg_q_t npTxQueue;
   \                     npTxQueue:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    100          
    101          /* ------------------------------------------------------------------------------------------------
    102           *                                           Global Variables
    103           * ------------------------------------------------------------------------------------------------
    104           */
    105          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    106          uint8 znpCfg1;
   \                     znpCfg1:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    107          uint8 znpCfg0;
   \                     znpCfg0:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    108          
    109          #if defined TC_LINKKEY_JOIN
    110          extern uint8 zcl_TaskID;
    111          #endif
    112          
    113          /**************************************************************************************************
    114           * @fn          znpInit
    115           *
    116           * @brief       This function is the OSAL task initialization callback.
    117           *
    118           * input parameters
    119           *
    120           * @param taskId - The task ID assigned to this task by the OSAL.
    121           *
    122           * output parameters
    123           *
    124           * None.
    125           *
    126           * @return      None.
    127           **************************************************************************************************
    128           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    129          void znpInit(uint8 taskId)
   \                     znpInit:
    130          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
    131            znpTaskId = taskId;
   \   000006   90....       MOV       DPTR,#MT_TaskID
   \   000009   F0           MOVX      @DPTR,A
    132            (void)osal_set_event(taskId, ZNP_SECONDARY_INIT_EVENT);
   \   00000A                ; Setup parameters for call to function osal_set_event
   \   00000A   7A10         MOV       R2,#0x10
   \   00000C   7B00         MOV       R3,#0x0
   \   00000E   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    133          #if defined MT_ZNP_FUNC
    134            znpBasicRspRate = ZNP_BASIC_RSP_RATE;
    135            (void)osal_start_reload_timer(taskId, ZNP_BASIC_RSP_EVENT, ZNP_BASIC_RSP_RATE);
    136          #endif
    137          }
   \   000011                REQUIRE ?Subroutine0
   \   000011                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    138          
    139          /**************************************************************************************************
    140           * @fn          znpEventLoop
    141           *
    142           * @brief       This function processes the OSAL events and messages for the application.
    143           *
    144           * input parameters
    145           *
    146           * @param taskId - The task ID assigned to this application by OSAL at system initialization.
    147           * @param events - A bit mask of the pending event(s).
    148           *
    149           * output parameters
    150           *
    151           * None.
    152           *
    153           * @return      The events bit map received via parameter with the bits cleared which correspond to
    154           *              the event(s) that were processed on this invocation.
    155           **************************************************************************************************
    156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    157          uint16 znpEventLoop(uint8 taskId, uint16 events)
   \                     znpEventLoop:
    158          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    159            osal_event_hdr_t *pMsg;
    160          #if !defined CC2531ZNP
    161            uint8 *pBuf;
    162          #endif
    163          
    164            if (events & SYS_EVENT_MSG)
   \   000009   5480         ANL       A,#0x80
   \   00000B   7021         JNZ       ??znpEventLoop_0
    165            {
    166              while ((pMsg = (osal_event_hdr_t *) osal_msg_receive(znpTaskId)) != NULL)
    167              {
    168                switch (pMsg->event)
    169                {
    170                /* incoming message from UART transport */
    171                case CMD_SERIAL_MSG:
    172                  MT_ProcessIncoming(((mtOSALSerialData_t *)pMsg)->msg);
    173                  break;
    174          
    175          #if defined ZCL_KEY_ESTABLISH
    176          #if defined (MT_UTIL_FUNC)
    177                case ZCL_KEY_ESTABLISH_IND:
    178                  MT_UtilKeyEstablishInd((zclKE_StatusInd_t *)pMsg);
    179                  break;
    180          #endif
    181          #endif
    182          
    183                case AF_INCOMING_MSG_CMD:
    184          #if defined ZCL_KEY_ESTABLISH
    185                  if (ZCL_KE_ENDPOINT == (((afIncomingMSGPacket_t *)pMsg)->endPoint))
    186                  {
    187                    zcl_ProcessMessageMSG((afIncomingMSGPacket_t *)pMsg);
    188                  }
    189                  else
    190          #endif
    191                  {
    192                    MT_AfIncomingMsg((afIncomingMSGPacket_t *)pMsg);
    193                  }
    194                  break;
    195          
    196          #ifdef MT_ZDO_FUNC
    197                case ZDO_STATE_CHANGE:
    198                  MT_ZdoStateChangeCB(pMsg);
    199                  break;
    200          
    201                case ZDO_CB_MSG:
    202                  MT_ZdoSendMsgCB((zdoIncomingMsg_t *)pMsg);
    203                  break;
    204          #endif
    205          
    206                case AF_DATA_CONFIRM_CMD:
    207                  MT_AfDataConfirm((afDataConfirm_t *)pMsg);
    208                  break;
    209          
    210                default:
    211                  break;
    212                }
    213          
    214                osal_msg_deallocate((byte *)pMsg);
    215              }
    216          
    217              events ^= SYS_EVENT_MSG;
    218            }
    219          #if !defined CC2531ZNP
    220            else if (events & ZNP_SPI_RX_AREQ_EVENT)
   \   00000D   EB           MOV       A,R3
   \   00000E   5440         ANL       A,#0x40
   \   000010   6066         JZ        ??znpEventLoop_1
    221            {
    222              if ((pBuf = npSpiGetReqBuf()) != NULL )
   \   000012                ; Setup parameters for call to function npSpiGetReqBuf
   \   000012   12....       LCALL     `??npSpiGetReqBuf::?relay`; Banked call to: npSpiGetReqBuf
   \   000015   EA           MOV       A,R2
   \   000016   4B           ORL       A,R3
   \   000017   6006         JZ        ??znpEventLoop_2
    223              {
    224                MT_ProcessIncoming(pBuf);
   \   000019                ; Setup parameters for call to function MT_ProcessIncoming
   \   000019   12....       LCALL     `??MT_ProcessIncoming::?relay`; Banked call to: MT_ProcessIncoming
    225                npSpiAReqComplete();
   \   00001C                ; Setup parameters for call to function npSpiAReqComplete
   \   00001C   12....       LCALL     `??npSpiAReqComplete::?relay`; Banked call to: npSpiAReqComplete
    226              }
    227          
    228              events ^= ZNP_SPI_RX_AREQ_EVENT;
   \                     ??znpEventLoop_2:
   \   00001F   7440         MOV       A,#0x40
   \   000021   02....       LJMP      ??znpEventLoop_3 & 0xFFFF
    229            }
   \                     ??znpEventLoop_4:
   \   000024                ; Setup parameters for call to function MT_AfDataConfirm
   \   000024   12....       LCALL     `??MT_AfDataConfirm::?relay`; Banked call to: MT_AfDataConfirm
   \                     ??znpEventLoop_5:
   \   000027                ; Setup parameters for call to function osal_msg_deallocate
   \   000027   AA..         MOV       R2,?V0
   \   000029   AB..         MOV       R3,?V1
   \   00002B   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \                     ??znpEventLoop_0:
   \   00002E                ; Setup parameters for call to function osal_msg_receive
   \   00002E   90....       MOV       DPTR,#MT_TaskID
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F9           MOV       R1,A
   \   000033   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000036   8A..         MOV       ?V0,R2
   \   000038   8B..         MOV       ?V1,R3
   \   00003A   EA           MOV       A,R2
   \   00003B   4B           ORL       A,R3
   \   00003C   6035         JZ        ??znpEventLoop_6
   \   00003E   8A82         MOV       DPL,R2
   \   000040   8B83         MOV       DPH,R3
   \   000042   E0           MOVX      A,@DPTR
   \   000043   14           DEC       A
   \   000044   6012         JZ        ??znpEventLoop_7
   \   000046   24E7         ADD       A,#-0x19
   \   000048   601A         JZ        ??znpEventLoop_8
   \   00004A   2449         ADD       A,#0x49
   \   00004C   601B         JZ        ??znpEventLoop_9
   \   00004E   24FE         ADD       A,#-0x2
   \   000050   601C         JZ        ??znpEventLoop_10
   \   000052   24D6         ADD       A,#-0x2a
   \   000054   60CE         JZ        ??znpEventLoop_4
   \   000056   80CF         SJMP      ??znpEventLoop_5
   \                     ??znpEventLoop_7:
   \   000058                ; Setup parameters for call to function MT_ProcessIncoming
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   FA           MOV       R2,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   FB           MOV       R3,A
   \   00005F   12....       LCALL     `??MT_ProcessIncoming::?relay`; Banked call to: MT_ProcessIncoming
   \   000062   80C3         SJMP      ??znpEventLoop_5
   \                     ??znpEventLoop_8:
   \   000064                ; Setup parameters for call to function MT_AfIncomingMsg
   \   000064   12....       LCALL     `??MT_AfIncomingMsg::?relay`; Banked call to: MT_AfIncomingMsg
   \   000067   80BE         SJMP      ??znpEventLoop_5
   \                     ??znpEventLoop_9:
   \   000069                ; Setup parameters for call to function MT_ZdoStateChangeCB
   \   000069   12....       LCALL     `??MT_ZdoStateChangeCB::?relay`; Banked call to: MT_ZdoStateChangeCB
   \   00006C   80B9         SJMP      ??znpEventLoop_5
   \                     ??znpEventLoop_10:
   \   00006E                ; Setup parameters for call to function MT_ZdoSendMsgCB
   \   00006E   12....       LCALL     `??MT_ZdoSendMsgCB::?relay`; Banked call to: MT_ZdoSendMsgCB
   \   000071   80B4         SJMP      ??znpEventLoop_5
   \                     ??znpEventLoop_6:
   \   000073   7480         MOV       A,#-0x80
   \   000075   02....       LJMP      ??znpEventLoop_3 & 0xFFFF
    230            else if (events & ZNP_SPI_RX_SREQ_EVENT)
   \                     ??znpEventLoop_1:
   \   000078   EB           MOV       A,R3
   \   000079   5420         ANL       A,#0x20
   \   00007B   600F         JZ        ??znpEventLoop_11
    231            {
    232              if ((pBuf = npSpiGetReqBuf()) != NULL)
   \   00007D                ; Setup parameters for call to function npSpiGetReqBuf
   \   00007D   12....       LCALL     `??npSpiGetReqBuf::?relay`; Banked call to: npSpiGetReqBuf
   \   000080   EA           MOV       A,R2
   \   000081   4B           ORL       A,R3
   \   000082   6003         JZ        ??znpEventLoop_12
    233              {
    234                MT_ProcessIncoming(pBuf);
   \   000084                ; Setup parameters for call to function MT_ProcessIncoming
   \   000084   12....       LCALL     `??MT_ProcessIncoming::?relay`; Banked call to: MT_ProcessIncoming
    235              }
    236          
    237              events ^= ZNP_SPI_RX_SREQ_EVENT;
   \                     ??znpEventLoop_12:
   \   000087   7420         MOV       A,#0x20
   \   000089   02....       LJMP      ??znpEventLoop_3 & 0xFFFF
    238            }
    239          #endif
    240            else if (events & ZNP_UART_TX_READY_EVENT)
   \                     ??znpEventLoop_11:
   \   00008C   EB           MOV       A,R3
   \   00008D   5410         ANL       A,#0x10
   \   00008F   7003         JNZ       $+5
   \   000091   02....       LJMP      ??znpEventLoop_13 & 0xFFFF
    241            {
    242              npUartTxReady();
   \   000094   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000097   7036         JNZ       ??znpEventLoop_14
   \   000099                ; Setup parameters for call to function osal_msg_dequeue
   \   000099   7A..         MOV       R2,#npTxQueue & 0xff
   \   00009B   7B..         MOV       R3,#(npTxQueue >> 8) & 0xff
   \   00009D   12....       LCALL     `??osal_msg_dequeue::?relay`; Banked call to: osal_msg_dequeue
   \   0000A0   8B..         MOV       ?V1,R3
   \   0000A2   A9..         MOV       R1,?V1
   \   0000A4   90....       MOV       DPTR,#??npUartTxMsg
   \   0000A7   EA           MOV       A,R2
   \   0000A8   F0           MOVX      @DPTR,A
   \   0000A9   A3           INC       DPTR
   \   0000AA   EB           MOV       A,R3
   \   0000AB   F0           MOVX      @DPTR,A
   \   0000AC   90....       MOV       DPTR,#??pMsg
   \   0000AF   EA           MOV       A,R2
   \   0000B0   F0           MOVX      @DPTR,A
   \   0000B1   A3           INC       DPTR
   \   0000B2   EB           MOV       A,R3
   \   0000B3   F0           MOVX      @DPTR,A
   \   0000B4   EA           MOV       A,R2
   \   0000B5   49           ORL       A,R1
   \   0000B6   6017         JZ        ??znpEventLoop_14
   \   0000B8   E0           MOVX      A,@DPTR
   \   0000B9   F583         MOV       DPH,A
   \   0000BB   8A82         MOV       DPL,R2
   \   0000BD   A3           INC       DPTR
   \   0000BE   E0           MOVX      A,@DPTR
   \   0000BF   7900         MOV       R1,#0x0
   \   0000C1   2405         ADD       A,#0x5
   \   0000C3   5001         JNC       ??znpEventLoop_15
   \   0000C5   09           INC       R1
   \                     ??znpEventLoop_15:
   \   0000C6   90....       MOV       DPTR,#??npUartTxCnt
   \   0000C9   F0           MOVX      @DPTR,A
   \   0000CA   A3           INC       DPTR
   \   0000CB   E9           MOV       A,R1
   \   0000CC   F0           MOVX      @DPTR,A
   \   0000CD   8005         SJMP      ??znpEventLoop_16
   \                     ??znpEventLoop_14:
   \   0000CF   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   0000D2   604D         JZ        ??znpEventLoop_17
   \                     ??znpEventLoop_16:
   \   0000D4                ; Setup parameters for call to function HalUARTWrite
   \   0000D4   90....       MOV       DPTR,#??npUartTxCnt
   \   0000D7   E0           MOVX      A,@DPTR
   \   0000D8   FC           MOV       R4,A
   \   0000D9   A3           INC       DPTR
   \   0000DA   E0           MOVX      A,@DPTR
   \   0000DB   FD           MOV       R5,A
   \   0000DC   90....       MOV       DPTR,#??pMsg
   \   0000DF   E0           MOVX      A,@DPTR
   \   0000E0   FA           MOV       R2,A
   \   0000E1   A3           INC       DPTR
   \   0000E2   E0           MOVX      A,@DPTR
   \   0000E3   FB           MOV       R3,A
   \   0000E4   7900         MOV       R1,#0x0
   \   0000E6   12....       LCALL     `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
   \   0000E9   90....       MOV       DPTR,#??npUartTxCnt
   \   0000EC   C3           CLR       C
   \   0000ED   E0           MOVX      A,@DPTR
   \   0000EE   9A           SUBB      A,R2
   \   0000EF   F0           MOVX      @DPTR,A
   \   0000F0   A3           INC       DPTR
   \   0000F1   E0           MOVX      A,@DPTR
   \   0000F2   9B           SUBB      A,R3
   \   0000F3   F0           MOVX      @DPTR,A
   \   0000F4   90....       MOV       DPTR,#??npUartTxCnt
   \   0000F7   12....       LCALL     ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000FA   7013         JNZ       ??znpEventLoop_18
   \   0000FC                ; Setup parameters for call to function osal_msg_deallocate
   \   0000FC   90....       MOV       DPTR,#??npUartTxMsg
   \   0000FF   E0           MOVX      A,@DPTR
   \   000100   FA           MOV       R2,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   FB           MOV       R3,A
   \   000104   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \   000107   90....       MOV       DPTR,#??npUartTxMsg
   \   00010A   E4           CLR       A
   \   00010B   F0           MOVX      @DPTR,A
   \   00010C   A3           INC       DPTR
   \   00010D   8011         SJMP      ??znpEventLoop_19
   \                     ??znpEventLoop_18:
   \   00010F   90....       MOV       DPTR,#??pMsg
   \   000112   E0           MOVX      A,@DPTR
   \   000113   2A           ADD       A,R2
   \   000114   F8           MOV       R0,A
   \   000115   A3           INC       DPTR
   \   000116   E0           MOVX      A,@DPTR
   \   000117   3B           ADDC      A,R3
   \   000118   F9           MOV       R1,A
   \   000119   90....       MOV       DPTR,#??pMsg
   \   00011C   E8           MOV       A,R0
   \   00011D   F0           MOVX      @DPTR,A
   \   00011E   A3           INC       DPTR
   \   00011F   E9           MOV       A,R1
   \                     ??znpEventLoop_19:
   \   000120   F0           MOVX      @DPTR,A
    243              events ^= ZNP_UART_TX_READY_EVENT;
   \                     ??znpEventLoop_17:
   \   000121   7410         MOV       A,#0x10
   \   000123   8036         SJMP      ??znpEventLoop_3
    244            }
    245          #if defined MT_SYS_FUNC
    246            else if (events & MT_SYS_OSAL_EVENT_0)
   \                     ??znpEventLoop_13:
   \   000125   EB           MOV       A,R3
   \   000126   5408         ANL       A,#0x8
   \   000128   6009         JZ        ??znpEventLoop_20
    247            {
    248              MT_SysOsalTimerExpired(0x00);
   \   00012A                ; Setup parameters for call to function MT_SysOsalTimerExpired
   \   00012A   7900         MOV       R1,#0x0
   \   00012C   12....       LCALL     `??MT_SysOsalTimerExpired::?relay`; Banked call to: MT_SysOsalTimerExpired
    249              events ^= MT_SYS_OSAL_EVENT_0;
   \   00012F   7408         MOV       A,#0x8
   \   000131   8028         SJMP      ??znpEventLoop_3
    250            }
    251            else if (events & MT_SYS_OSAL_EVENT_1)
   \                     ??znpEventLoop_20:
   \   000133   EB           MOV       A,R3
   \   000134   5404         ANL       A,#0x4
   \   000136   6009         JZ        ??znpEventLoop_21
    252            {
    253              MT_SysOsalTimerExpired(0x01);
   \   000138                ; Setup parameters for call to function MT_SysOsalTimerExpired
   \   000138   7901         MOV       R1,#0x1
   \   00013A   12....       LCALL     `??MT_SysOsalTimerExpired::?relay`; Banked call to: MT_SysOsalTimerExpired
    254              events ^= MT_SYS_OSAL_EVENT_1;
   \   00013D   7404         MOV       A,#0x4
   \   00013F   801A         SJMP      ??znpEventLoop_3
    255            }
    256            else if (events & MT_SYS_OSAL_EVENT_2)
   \                     ??znpEventLoop_21:
   \   000141   EB           MOV       A,R3
   \   000142   5402         ANL       A,#0x2
   \   000144   6009         JZ        ??znpEventLoop_22
    257            {
    258              MT_SysOsalTimerExpired(0x02);
   \   000146                ; Setup parameters for call to function MT_SysOsalTimerExpired
   \   000146   7902         MOV       R1,#0x2
   \   000148   12....       LCALL     `??MT_SysOsalTimerExpired::?relay`; Banked call to: MT_SysOsalTimerExpired
    259              events ^= MT_SYS_OSAL_EVENT_2;
   \   00014B   7402         MOV       A,#0x2
   \   00014D   800C         SJMP      ??znpEventLoop_3
    260            }
    261            else if (events & MT_SYS_OSAL_EVENT_3)
   \                     ??znpEventLoop_22:
   \   00014F   EB           MOV       A,R3
   \   000150   5401         ANL       A,#0x1
   \   000152   600B         JZ        ??znpEventLoop_23
    262            {
    263              MT_SysOsalTimerExpired(0x03);
   \   000154                ; Setup parameters for call to function MT_SysOsalTimerExpired
   \   000154   7903         MOV       R1,#0x3
   \   000156   12....       LCALL     `??MT_SysOsalTimerExpired::?relay`; Banked call to: MT_SysOsalTimerExpired
    264              events ^= MT_SYS_OSAL_EVENT_3;
   \   000159   7401         MOV       A,#0x1
   \                     ??znpEventLoop_3:
   \   00015B   6F           XRL       A,R7
   \   00015C   FF           MOV       R7,A
   \   00015D   801E         SJMP      ??znpEventLoop_24
    265            }
    266          #endif
    267          #if defined POWER_SAVING
    268            else if (events & ZNP_PWRMGR_CONSERVE_EVENT)
    269            {
    270              (void)osal_pwrmgr_task_state(znpTaskId, PWRMGR_CONSERVE);
    271              events ^= ZNP_PWRMGR_CONSERVE_EVENT;
    272            }
    273          #endif
    274            else if (events & ZNP_SECONDARY_INIT_EVENT)
   \                     ??znpEventLoop_23:
   \   00015F   EA           MOV       A,R2
   \   000160   5410         ANL       A,#0x10
   \   000162   6007         JZ        ??znpEventLoop_25
    275            {
    276              npInit();
   \   000164                ; Setup parameters for call to function npInit
   \   000164   12....       LCALL     `??npInit::?relay`; Banked call to: npInit
    277              events ^= ZNP_SECONDARY_INIT_EVENT;
   \   000167   7410         MOV       A,#0x10
   \   000169   800A         SJMP      ??znpEventLoop_26
    278            }
    279          #if defined MT_ZNP_FUNC
    280            else if (events & ZNP_BASIC_RSP_EVENT)
    281            {
    282              npBasicRsp();
    283              events ^= ZNP_BASIC_RSP_EVENT;
    284            }
    285          #endif
    286            else if (events & MT_AF_EXEC_EVT)
   \                     ??znpEventLoop_25:
   \   00016B   EA           MOV       A,R2
   \   00016C   5408         ANL       A,#0x8
   \   00016E   6009         JZ        ??znpEventLoop_27
    287            {
    288              MT_AfExec();
   \   000170                ; Setup parameters for call to function MT_AfExec
   \   000170   12....       LCALL     `??MT_AfExec::?relay`; Banked call to: MT_AfExec
    289              events ^= MT_AF_EXEC_EVT;
   \   000173   7408         MOV       A,#0x8
   \                     ??znpEventLoop_26:
   \   000175   6E           XRL       A,R6
   \   000176   FE           MOV       R6,A
   \   000177   8004         SJMP      ??znpEventLoop_24
    290            }
    291            else
    292            {
    293              events = 0;  /* Discard unknown events. */
   \                     ??znpEventLoop_27:
   \   000179   7E00         MOV       R6,#0x0
   \   00017B   7F00         MOV       R7,#0x0
    294            }
    295          
    296            return ( events );
   \                     ??znpEventLoop_24:
   \   00017D   EE           MOV       A,R6
   \   00017E   FA           MOV       R2,A
   \   00017F   EF           MOV       A,R7
   \   000180   FB           MOV       R3,A
   \   000181   7F04         MOV       R7,#0x4
   \   000183   02....       LJMP      ?BANKED_LEAVE_XDATA
    297          }
    298          
    299          /**************************************************************************************************
    300           * @fn          MT_TransportAlloc
    301           *
    302           * @brief       This function is the definition of the physical transport API for allocation a msg.
    303           *
    304           * input parameters
    305           *
    306           * @param cmd0 - The RPC command byte 0.
    307           * @param len - The RPC data length.
    308           *
    309           * output parameters
    310           *
    311           * @param uint8 * - Pointer to the buffer to use build and send the RPC message.
    312           *
    313           * @return      None.
    314           **************************************************************************************************
    315           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    316          uint8 *MT_TransportAlloc(uint8 cmd0, uint8 len)
   \                     MT_TransportAlloc:
    317          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FF           MOV       R7,A
    318          #if !defined CC2531ZNP
    319            if (ZNP_CFG1_UART == znpCfg1)
   \   000007   90....       MOV       DPTR,#znpCfg1
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   7024         JNZ       ??MT_TransportAlloc_0
    320          #endif
    321            {
    322              return npMtUartAlloc(cmd0, len);
   \   00000D                ; Setup parameters for call to function osal_msg_allocate
   \   00000D   EA           MOV       A,R2
   \   00000E   2405         ADD       A,#0x5
   \   000010   FA           MOV       R2,A
   \   000011   E4           CLR       A
   \   000012   3400         ADDC      A,#0x0
   \   000014   FB           MOV       R3,A
   \   000015   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000018   8A82         MOV       DPL,R2
   \   00001A   8B83         MOV       DPH,R3
   \   00001C   E582         MOV       A,DPL
   \   00001E   4583         ORL       A,DPH
   \   000020   6003         JZ        ??MT_TransportAlloc_1
   \   000022   A3           INC       DPTR
   \   000023   8006         SJMP      ??MT_TransportAlloc_2
   \                     ??MT_TransportAlloc_1:
   \   000025   758200       MOV       DPL,#0x0
   \   000028   758300       MOV       DPH,#0x0
    323            }
   \                     ??MT_TransportAlloc_2:
   \   00002B   AA82         MOV       R2,DPL
   \   00002D   AB83         MOV       R3,DPH
   \   00002F   8013         SJMP      ??MT_TransportAlloc_3
    324          #if !defined CC2531ZNP
    325            else
    326            {
    327              return npMtSpiAlloc(cmd0, len);
   \                     ??MT_TransportAlloc_0:
   \   000031   74E0         MOV       A,#-0x20
   \   000033   5F           ANL       A,R7
   \   000034   6460         XRL       A,#0x60
   \   000036   7007         JNZ       ??MT_TransportAlloc_4
   \   000038                ; Setup parameters for call to function npSpiSRspAlloc
   \   000038   EA           MOV       A,R2
   \   000039   F9           MOV       R1,A
   \   00003A   12....       LCALL     `??npSpiSRspAlloc::?relay`; Banked call to: npSpiSRspAlloc
   \   00003D   8005         SJMP      ??MT_TransportAlloc_3
   \                     ??MT_TransportAlloc_4:
   \   00003F                ; Setup parameters for call to function npSpiAReqAlloc
   \   00003F   EA           MOV       A,R2
   \   000040   F9           MOV       R1,A
   \   000041   12....       LCALL     `??npSpiAReqAlloc::?relay`; Banked call to: npSpiAReqAlloc
    328            }
   \                     ??MT_TransportAlloc_3:
   \   000044                REQUIRE ?Subroutine1
   \   000044                ; // Fall through to label ?Subroutine1
    329          #endif
    330          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    331          
    332          /**************************************************************************************************
    333           * @fn          MT_TransportSend
    334           *
    335           * @brief       This function is the definition of the physical transport API for sending a message.
    336           *
    337           * input parameters
    338           *
    339           * @param pBuf - Pointer to the buffer created with MT_TransportAlloc.
    340           *
    341           * output parameters
    342           *
    343           * None.
    344           *
    345           * @return      None.
    346           **************************************************************************************************
    347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          void MT_TransportSend(uint8 *pBuf)
   \                     MT_TransportSend:
    349          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    350          #if !defined CC2531ZNP
    351            if (ZNP_CFG1_UART == znpCfg1)
   \   000009   90....       MOV       DPTR,#znpCfg1
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   8A82         MOV       DPL,R2
   \   00000F   8B83         MOV       DPH,R3
   \   000011   703B         JNZ       ??MT_TransportSend_0
    352          #endif
    353            {
    354              npMtUartSend(pBuf);
   \   000013   E0           MOVX      A,@DPTR
   \   000014   2403         ADD       A,#0x3
   \   000016   F5..         MOV       ?V0,A
   \   000018                ; Setup parameters for call to function MT_UartCalcFCS
   \   000018   F9           MOV       R1,A
   \   000019   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   00001C   A8..         MOV       R0,?V0
   \   00001E   EE           MOV       A,R6
   \   00001F   28           ADD       A,R0
   \   000020   F582         MOV       DPL,A
   \   000022   E4           CLR       A
   \   000023   3F           ADDC      A,R7
   \   000024   F583         MOV       DPH,A
   \   000026   E9           MOV       A,R1
   \   000027   F0           MOVX      @DPTR,A
   \   000028   EE           MOV       A,R6
   \   000029   24FF         ADD       A,#-0x1
   \   00002B   F582         MOV       DPL,A
   \   00002D   EF           MOV       A,R7
   \   00002E   34FF         ADDC      A,#-0x1
   \   000030   F583         MOV       DPH,A
   \   000032   74FE         MOV       A,#-0x2
   \   000034   F0           MOVX      @DPTR,A
   \   000035                ; Setup parameters for call to function osal_msg_enqueue
   \   000035   AC82         MOV       R4,DPL
   \   000037   AD83         MOV       R5,DPH
   \   000039   7A..         MOV       R2,#npTxQueue & 0xff
   \   00003B   7B..         MOV       R3,#(npTxQueue >> 8) & 0xff
   \   00003D   12....       LCALL     `??osal_msg_enqueue::?relay`; Banked call to: osal_msg_enqueue
   \   000040                ; Setup parameters for call to function osal_set_event
   \   000040   7A00         MOV       R2,#0x0
   \   000042   7B10         MOV       R3,#0x10
   \   000044   90....       MOV       DPTR,#MT_TaskID
   \   000047   E0           MOVX      A,@DPTR
   \   000048   F9           MOV       R1,A
   \   000049   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    355            }
   \   00004C   801B         SJMP      ??MT_TransportSend_1
    356          #if !defined CC2531ZNP
    357            else
    358            {
    359              npMtSpiSend(pBuf);
   \                     ??MT_TransportSend_0:
   \   00004E   A3           INC       DPTR
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   54E0         ANL       A,#0xe0
   \   000052   6460         XRL       A,#0x60
   \   000054   7005         JNZ       ??MT_TransportSend_2
   \   000056                ; Setup parameters for call to function npSpiSRspReady
   \   000056   12....       LCALL     `??npSpiSRspReady::?relay`; Banked call to: npSpiSRspReady
   \   000059   800E         SJMP      ??MT_TransportSend_1
   \                     ??MT_TransportSend_2:
   \   00005B                ; Setup parameters for call to function osal_msg_enqueue
   \   00005B   EA           MOV       A,R2
   \   00005C   FC           MOV       R4,A
   \   00005D   EB           MOV       A,R3
   \   00005E   FD           MOV       R5,A
   \   00005F   7A..         MOV       R2,#npTxQueue & 0xff
   \   000061   7B..         MOV       R3,#(npTxQueue >> 8) & 0xff
   \   000063   12....       LCALL     `??osal_msg_enqueue::?relay`; Banked call to: osal_msg_enqueue
   \   000066                ; Setup parameters for call to function npSpiAReqReady
   \   000066   12....       LCALL     `??npSpiAReqReady::?relay`; Banked call to: npSpiAReqReady
    360            }
    361          #endif
    362          }
   \                     ??MT_TransportSend_1:
   \   000069   02....       LJMP      ?Subroutine0 & 0xFFFF
    363          
    364          /**************************************************************************************************
    365           * @fn         npInit
    366           *
    367           * @brief      This function is the secondary initialization that resolves conflicts during
    368           *             osalInitTasks(). For example, since ZNP is the highest priority task, and
    369           *             specifically because the ZNP task is initialized before the ZDApp task, if znpInit()
    370           *             registers anything with ZDO_RegisterForZdoCB(), it is wiped out when ZDApp task
    371           *             initialization invokes ZDApp_InitZdoCBFunc().
    372           *             There may be other existing or future such races, so try to do all possible
    373           *             NP initialization here vice in znpInit().
    374           *
    375           * input parameters
    376           *
    377           * None.
    378           *
    379           * output parameters
    380           *
    381           * None.
    382           *
    383           * @return      None.
    384           **************************************************************************************************
    385           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    386          static void npInit(void)
   \                     npInit:
    387          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 29
   \   000005   74E3         MOV       A,#-0x1d
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    388            if (ZNP_CFG1_UART == znpCfg1)
   \   00000A   90....       MOV       DPTR,#znpCfg1
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   7062         JNZ       ??npInit_0
    389            {
    390              halUARTCfg_t uartConfig;
    391          
    392              uartConfig.configured           = TRUE;
   \   000010   85..82       MOV       DPL,?XSP + 0
   \   000013   85..83       MOV       DPH,?XSP + 1
   \   000016   7401         MOV       A,#0x1
   \   000018   F0           MOVX      @DPTR,A
    393              uartConfig.baudRate             = ZNP_UART_BAUD;
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   7404         MOV       A,#0x4
   \   00001E   F0           MOVX      @DPTR,A
    394          #ifdef ZNP_ALT
    395              uartConfig.flowControl          = FALSE;
   \   00001F   7402         MOV       A,#0x2
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   E4           CLR       A
   \   000025   F0           MOVX      @DPTR,A
    396          #else
    397              uartConfig.flowControl          = FALSE;
    398          #endif
    399              uartConfig.flowControlThreshold = HAL_UART_FLOW_THRESHOLD;
   \   000026   7403         MOV       A,#0x3
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   E4           CLR       A
   \   00002C   F0           MOVX      @DPTR,A
   \   00002D   A3           INC       DPTR
   \   00002E   F0           MOVX      @DPTR,A
    400              uartConfig.rx.maxBufSize        = HAL_UART_RX_BUF_SIZE;
   \   00002F   740A         MOV       A,#0xa
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E4           CLR       A
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   F0           MOVX      @DPTR,A
    401              uartConfig.tx.maxBufSize        = HAL_UART_TX_BUF_SIZE;
   \   000038   7412         MOV       A,#0x12
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   E4           CLR       A
   \   00003E   F0           MOVX      @DPTR,A
   \   00003F   A3           INC       DPTR
   \   000040   F0           MOVX      @DPTR,A
    402              uartConfig.idleTimeout          = HAL_UART_IDLE_TIMEOUT;
   \   000041   7405         MOV       A,#0x5
   \   000043   12....       LCALL     ?XSTACK_DISP0_8
   \   000046   E4           CLR       A
   \   000047   F0           MOVX      @DPTR,A
    403              uartConfig.intEnable            = TRUE;
   \   000048   7416         MOV       A,#0x16
   \   00004A   12....       LCALL     ?XSTACK_DISP0_8
   \   00004D   7401         MOV       A,#0x1
   \   00004F   F0           MOVX      @DPTR,A
    404              uartConfig.callBackFunc         = npUartCback;
   \   000050   741B         MOV       A,#0x1b
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   74..         MOV       A,#`??npUartCback::?relay` & 0xff
   \   000057   F0           MOVX      @DPTR,A
   \   000058   A3           INC       DPTR
   \   000059   74..         MOV       A,#(`??npUartCback::?relay` >> 8) & 0xff
   \   00005B   F0           MOVX      @DPTR,A
    405              HalUARTOpen(HAL_UART_PORT, &uartConfig);
   \   00005C                ; Setup parameters for call to function HalUARTOpen
   \   00005C   AA..         MOV       R2,?XSP + 0
   \   00005E   AB..         MOV       R3,?XSP + 1
   \   000060   7900         MOV       R1,#0x0
   \   000062   12....       LCALL     `??HalUARTOpen::?relay`; Banked call to: HalUARTOpen
    406              MT_UartRegisterTaskID(znpTaskId);
   \   000065                ; Setup parameters for call to function MT_UartRegisterTaskID
   \   000065   90....       MOV       DPTR,#MT_TaskID
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F9           MOV       R1,A
   \   00006A   12....       LCALL     `??MT_UartRegisterTaskID::?relay`; Banked call to: MT_UartRegisterTaskID
    407          
    408          #ifdef HAL_PA_LNA_CC2592
    409             ZMacSetTransmitPower(TX_PWR_PLUS_19);
    410          #else
    411             ZMacSetTransmitPower(TX_PWR_PLUS_4);
   \   00006D                ; Setup parameters for call to function ZMacSetTransmitPower
   \   00006D   7904         MOV       R1,#0x4
   \   00006F   12....       LCALL     `??ZMacSetTransmitPower::?relay`; Banked call to: ZMacSetTransmitPower
    412          #endif 
    413            }
    414            else
    415            {
    416              /* npSpiInit() is called by hal_spi.c: HalSpiInit().*/
    417            }
    418          
    419            npInitNV();
   \                     ??npInit_0:
   \   000072                ; Setup parameters for call to function osal_nv_item_init
   \   000072   E4           CLR       A
   \   000073   F5..         MOV       ?V0,A
   \   000075   F5..         MOV       ?V1,A
   \   000077   78..         MOV       R0,#?V0
   \   000079   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007C   7C02         MOV       R4,#0x2
   \   00007E   7D00         MOV       R5,#0x0
   \   000080   7A01         MOV       R2,#0x1
   \   000082   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000085   12....       LCALL     ?DEALLOC_XSTACK8
   \   000088                ; Setup parameters for call to function osal_nv_item_init
   \   000088   78..         MOV       R0,#?V0
   \   00008A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008D   7C02         MOV       R4,#0x2
   \   00008F   7D00         MOV       R5,#0x0
   \   000091   7A02         MOV       R2,#0x2
   \   000093   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000096   12....       LCALL     ?DEALLOC_XSTACK8
   \   000099                ; Setup parameters for call to function osal_nv_item_init
   \   000099   78..         MOV       R0,#?V0
   \   00009B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009E   7C02         MOV       R4,#0x2
   \   0000A0   7D00         MOV       R5,#0x0
   \   0000A2   7A03         MOV       R2,#0x3
   \   0000A4   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000A7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000AA                ; Setup parameters for call to function osal_nv_item_init
   \   0000AA   78..         MOV       R0,#?V0
   \   0000AC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AF   7C02         MOV       R4,#0x2
   \   0000B1   7D00         MOV       R5,#0x0
   \   0000B3   7A04         MOV       R2,#0x4
   \   0000B5   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000B8   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000BB                ; Setup parameters for call to function osal_nv_item_init
   \   0000BB   78..         MOV       R0,#?V0
   \   0000BD   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C0   7C10         MOV       R4,#0x10
   \   0000C2   7D00         MOV       R5,#0x0
   \   0000C4   7A05         MOV       R2,#0x5
   \   0000C6   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000C9   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000CC                ; Setup parameters for call to function osal_nv_item_init
   \   0000CC   78..         MOV       R0,#?V0
   \   0000CE   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000D1   7C10         MOV       R4,#0x10
   \   0000D3   7D00         MOV       R5,#0x0
   \   0000D5   7A06         MOV       R2,#0x6
   \   0000D7   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000DA   12....       LCALL     ?DEALLOC_XSTACK8
    420          #if defined (MT_ZDO_FUNC)
    421            MT_ZdoInit();
   \   0000DD                ; Setup parameters for call to function MT_ZdoInit
   \   0000DD   12....       LCALL     `??MT_ZdoInit::?relay`; Banked call to: MT_ZdoInit
    422          #endif
    423            MT_SysResetInd();
   \   0000E0                ; Setup parameters for call to function MT_SysResetInd
   \   0000E0   12....       LCALL     `??MT_SysResetInd::?relay`; Banked call to: MT_SysResetInd
    424          #if defined ZCL_KEY_ESTABLISH
    425          #if defined TC_LINKKEY_JOIN
    426            zcl_TaskID = znpTaskId;
    427          #endif
    428          #endif
    429          #if LQI_ADJUST
    430            ZMacLqiAdjustMode(LQI_ADJ_MODE1);
    431          #endif
    432          #if defined CC2531ZNP
    433            (void)osal_pwrmgr_task_state(znpTaskId, PWRMGR_HOLD);
    434          #endif
    435          }
   \   0000E3   741D         MOV       A,#0x1d
   \   0000E5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000E8   02....       LJMP      ?Subroutine1 & 0xFFFF
    436          
    437          /**************************************************************************************************
    438           * @fn         npInitNV
    439           *
    440           * @brief
    441           *
    442           * input parameters
    443           *
    444           * None.
    445           *
    446           * output parameters
    447           *
    448           * None.
    449           *
    450           * @return      None.
    451           **************************************************************************************************
    452           */
    453          static void npInitNV(void)
    454          {
    455            /* 4 x 2 bytes ZNP_NV_APP_ITEM_X */
    456            osal_nv_item_init(ZNP_NV_APP_ITEM_1, 2, NULL);
    457            osal_nv_item_init(ZNP_NV_APP_ITEM_2, 2, NULL);
    458            osal_nv_item_init(ZNP_NV_APP_ITEM_3, 2, NULL);
    459            osal_nv_item_init(ZNP_NV_APP_ITEM_4, 2, NULL);
    460          
    461            /* 2 x 16 bytes ZNP_NV_APP_ITEM_X */
    462            osal_nv_item_init(ZNP_NV_APP_ITEM_5, 16, NULL);
    463            osal_nv_item_init(ZNP_NV_APP_ITEM_6, 16, NULL);
    464          }
    465          
    466          #if defined MT_ZNP_FUNC
    467          /**************************************************************************************************
    468           * @fn         npBasicRsp
    469           *
    470           * @brief      Generate the ZNP Basic Response message to the ZAP.
    471           *
    472           * input parameters
    473           *
    474           * None.
    475           *
    476           * output parameters
    477           *
    478           * None.
    479           *
    480           * @return      None.
    481           **************************************************************************************************
    482           */
    483          static void npBasicRsp(void)
    484          {
    485            if (MT_ZnpBasicRsp() == false)
    486            {
    487              (void)osal_set_event(znpTaskId, ZNP_BASIC_RSP_EVENT);
    488            }
    489          }
    490          #endif
    491          
    492          /**************************************************************************************************
    493           * @fn          npUartCback
    494           *
    495           * @brief       This function is the UART callback processor.
    496           *
    497           * input parameters
    498           *
    499           * @param port - The port being used for UART.
    500           * @param event - The reason for the callback.
    501           *
    502           * output parameters
    503           *
    504           * None.
    505           *
    506           * @return      None.
    507           **************************************************************************************************
    508           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    509          static void npUartCback(uint8 port, uint8 event)
   \                     npUartCback:
    510          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
    511            switch (event) {
   \   000006   14           DEC       A
   \   000007   600D         JZ        ??npUartCback_0
   \   000009   14           DEC       A
   \   00000A   600A         JZ        ??npUartCback_0
   \   00000C   24FE         ADD       A,#-0x2
   \   00000E   6006         JZ        ??npUartCback_0
   \   000010   24F4         ADD       A,#-0xc
   \   000012   600C         JZ        ??npUartCback_1
   \   000014   8016         SJMP      ??npUartCback_2
    512            case HAL_UART_RX_FULL:
    513            case HAL_UART_RX_ABOUT_FULL:
    514            case HAL_UART_RX_TIMEOUT:
    515              MT_UartProcessZToolData(port, znpTaskId);
   \                     ??npUartCback_0:
   \   000016                ; Setup parameters for call to function MT_UartProcessZToolData
   \   000016   90....       MOV       DPTR,#MT_TaskID
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   FA           MOV       R2,A
   \   00001B   12....       LCALL     `??MT_UartProcessZToolData::?relay`; Banked call to: MT_UartProcessZToolData
    516              break;
   \   00001E   800C         SJMP      ??npUartCback_2
    517          
    518            case HAL_UART_TX_EMPTY:
    519              osal_set_event(znpTaskId, ZNP_UART_TX_READY_EVENT);
   \                     ??npUartCback_1:
   \   000020                ; Setup parameters for call to function osal_set_event
   \   000020   7A00         MOV       R2,#0x0
   \   000022   7B10         MOV       R3,#0x10
   \   000024   90....       MOV       DPTR,#MT_TaskID
   \   000027   E0           MOVX      A,@DPTR
   \   000028   F9           MOV       R1,A
   \   000029   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    520              break;
    521          
    522            default:
    523              break;
    524            }
    525          }
   \                     ??npUartCback_2:
   \   00002C   02....       LJMP      ?Subroutine0 & 0xFFFF
    526          
    527          /**************************************************************************************************
    528           * @fn          npUartTxReady
    529           *
    530           * @brief       This function gets and writes the next chunk of data to the UART.
    531           *
    532           * input parameters
    533           *
    534           * None.
    535           *
    536           * output parameters
    537           *
    538           * None.
    539           *
    540           * @return      None.
    541           **************************************************************************************************
    542           */
    543          static void npUartTxReady(void)
    544          {

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    545            static uint16 npUartTxCnt = 0;
   \                     ??npUartTxCnt:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    546            static uint8 *npUartTxMsg = NULL;
   \                     ??npUartTxMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    547            static uint8 *pMsg = NULL;
   \                     ??pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    548          
    549            if (!npUartTxMsg)
    550            {
    551              if ((pMsg = npUartTxMsg = osal_msg_dequeue(&npTxQueue)))
    552              {
    553                /* | SOP | Data Length | CMD |  DATA   | FSC |
    554                 * |  1  |     1       |  2  | as dLen |  1  |
    555                 */
    556                npUartTxCnt = pMsg[1] + MT_UART_FRAME_OVHD + MT_RPC_FRAME_HDR_SZ;
    557              }
    558            }
    559          
    560            if (npUartTxMsg)
    561            {
    562              uint16 len = HalUARTWrite(HAL_UART_PORT, pMsg, npUartTxCnt);
    563              npUartTxCnt -= len;
    564          
    565              if (npUartTxCnt == 0)
    566              {
    567                osal_msg_deallocate(npUartTxMsg);
    568                npUartTxMsg = NULL;
    569              }
    570              else
    571              {
    572                pMsg += len;
    573              }
    574            }
    575          }
    576          
    577          /**************************************************************************************************
    578           * @fn          npMtUartAlloc
    579           *
    580           * @brief       This function allocates a buffer for Txing on UART.
    581           *
    582           * input parameters
    583           *
    584           * @param cmd0 - The first byte of the MT command id containing the command type and subsystem.
    585           * @param len - Data length required.
    586           *
    587           * output parameters
    588           *
    589           * None.
    590           *
    591           * @return      Pointer to the buffer obtained; possibly NULL if an allocation failed.
    592           **************************************************************************************************
    593           */
    594          static uint8* npMtUartAlloc(uint8 cmd0, uint8 len)
    595          {
    596            uint8 *p;
    597          
    598            if ((p = osal_msg_allocate(len + MT_RPC_FRAME_HDR_SZ + MT_UART_FRAME_OVHD)) != NULL)
    599            {
    600              return p + 1;
    601            }
    602          
    603            return NULL;
    604          }
    605          
    606          /**************************************************************************************************
    607           * @fn          npMtUartSend
    608           *
    609           * @brief       This function transmits or enqueues the buffer for transmitting on UART.
    610           *
    611           * input parameters
    612           *
    613           * @param pBuf - Pointer to the buffer to transmit on the UART.
    614           *
    615           * output parameters
    616           *
    617           * None.
    618           *
    619           * @return      None.
    620           **************************************************************************************************
    621           */
    622          static void npMtUartSend(uint8 *pBuf)
    623          {
    624            uint8 len = pBuf[0] + MT_RPC_FRAME_HDR_SZ;
    625          
    626            pBuf[len] = MT_UartCalcFCS(pBuf, len);
    627            pBuf--;
    628            pBuf[0] = MT_UART_SOF;
    629          
    630            osal_msg_enqueue(&npTxQueue, pBuf);
    631            osal_set_event(znpTaskId, ZNP_UART_TX_READY_EVENT);
    632          }
    633          
    634          #if !defined CC2531ZNP
    635          /**************************************************************************************************
    636           * @fn          npMtSpiAlloc
    637           *
    638           * @brief       This function gets or allocates a buffer for Txing on SPI.
    639           *
    640           * input parameters
    641           *
    642           * @param cmd0 - The first byte of the MT command id containing the command type and subsystem.
    643           * @param len - Data length required.
    644           *
    645           * output parameters
    646           *
    647           * None.
    648           *
    649           * @return      Pointer to the buffer obtained; possibly NULL if an allocation failed.
    650           **************************************************************************************************
    651           */
    652          static uint8* npMtSpiAlloc(uint8 cmd0, uint8 len)
    653          {
    654            if ((cmd0 & MT_RPC_CMD_TYPE_MASK) == MT_RPC_CMD_SRSP)
    655            {
    656              return npSpiSRspAlloc(len);
    657            }
    658            else
    659            {
    660              return npSpiAReqAlloc(len);
    661            }
    662          }
    663          
    664          /**************************************************************************************************
    665           * @fn          npMtSpiSend
    666           *
    667           * @brief       This function transmits or enqueues the buffer for transmitting on SPI.
    668           *
    669           * input parameters
    670           *
    671           * @param pBuf - Pointer to the buffer to transmit on the SPI.
    672           *
    673           * output parameters
    674           *
    675           * None.
    676           *
    677           * @return      None.
    678           **************************************************************************************************
    679           */
    680          static void npMtSpiSend(uint8 *pBuf)
    681          {
    682            if ((pBuf[1] & MT_RPC_CMD_TYPE_MASK) == MT_RPC_CMD_SRSP)
    683            {
    684              npSpiSRspReady(pBuf);
    685            }
    686            else
    687            {
    688              osal_msg_enqueue(&npTxQueue, pBuf);
    689              npSpiAReqReady();
    690            }
    691          }
    692          
    693          /**************************************************************************************************
    694           * @fn          npSpiPollCallback
    695           *
    696           * @brief       This function is called by the SPI driver when a POLL frame is received.
    697           *
    698           * input parameters
    699           *
    700           * None.
    701           *
    702           * output parameters
    703           *
    704           * None.
    705           *
    706           * @return      A pointer to an OSAL message buffer containing the next AREQ frame to transmit,
    707           *              if any; NULL otherwise.
    708           **************************************************************************************************
    709           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    710          uint8* npSpiPollCallback(void)
   \                     npSpiPollCallback:
    711          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    712            return osal_msg_dequeue(&npTxQueue);
   \   000004                ; Setup parameters for call to function osal_msg_dequeue
   \   000004   7A..         MOV       R2,#npTxQueue & 0xff
   \   000006   7B..         MOV       R3,#(npTxQueue >> 8) & 0xff
   \   000008   12....       LCALL     `??osal_msg_dequeue::?relay`; Banked call to: osal_msg_dequeue
   \   00000B                REQUIRE ?Subroutine2
   \   00000B                ; // Fall through to label ?Subroutine2
    713          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    714          
    715          /**************************************************************************************************
    716           * @fn          npSpiReadyCallback
    717           *
    718           * @brief       This function is called by the SPI driver to check if any data is ready to send.
    719           *
    720           * input parameters
    721           *
    722           * None.
    723           *
    724           * output parameters
    725           *
    726           * None.
    727           *
    728           * @return      TRUE if data is ready to send; FALSE otherwise.
    729           **************************************************************************************************
    730           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    731          bool npSpiReadyCallback(void)
   \                     npSpiReadyCallback:
    732          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    733            return !OSAL_MSG_Q_EMPTY(&npTxQueue);
   \   000004   90....       MOV       DPTR,#npTxQueue
   \   000007   12....       LCALL     ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00000A   6004         JZ        ??npSpiReadyCallback_0
   \   00000C   7901         MOV       R1,#0x1
   \   00000E   8002         SJMP      ??npSpiReadyCallback_1
   \                     ??npSpiReadyCallback_0:
   \   000010   7900         MOV       R1,#0x0
   \                     ??npSpiReadyCallback_1:
   \   000012   80..         SJMP      ?Subroutine2
    734          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine5_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   E8           MOV       A,R0
   \   000006   49           ORL       A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7B0F         MOV       R3,#0xf
   \   000002   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000005   7402         MOV       A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV       DPTR,#??npUartTxMsg
   \   000003                REQUIRE ??Subroutine5_0
   \   000003                ; // Fall through to label ??Subroutine5_0
    735          #endif
    736          
    737          /**************************************************************************************************
    738          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     10   MT_TransportAlloc
        0     10   -> npSpiAReqAlloc
        0     10   -> npSpiSRspAlloc
        0     10   -> osal_msg_allocate
      1      9   MT_TransportSend
        0      9   -> MT_UartCalcFCS
        0      9   -> npSpiAReqReady
        0      9   -> npSpiSRspReady
        0      9   -> osal_msg_enqueue
        0      9   -> osal_set_event
      0     53   npInit
        0     39   -> HalUARTOpen
        0     39   -> MT_SysResetInd
        0     39   -> MT_UartRegisterTaskID
        0     39   -> MT_ZdoInit
        0     39   -> ZMacSetTransmitPower
        0     41   -> osal_nv_item_init
      2      0   npSpiPollCallback
        2      0   -> osal_msg_dequeue
      2      0   npSpiReadyCallback
      0      9   npUartCback
        0      9   -> MT_UartProcessZToolData
        0      9   -> osal_set_event
      0     12   znpEventLoop
        0     12   -> HalUARTWrite
        0     12   -> MT_AfDataConfirm
        0     12   -> MT_AfExec
        0     12   -> MT_AfIncomingMsg
        0     12   -> MT_ProcessIncoming
        0     12   -> MT_SysOsalTimerExpired
        0     12   -> MT_ZdoSendMsgCB
        0     12   -> MT_ZdoStateChangeCB
        0     12   -> npInit
        0     12   -> npSpiAReqComplete
        0     12   -> npSpiGetReqBuf
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_dequeue
        0     12   -> osal_msg_receive
      0      9   znpInit
        0      9   -> osal_set_event


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine5_0
       5  ?Subroutine0
       5  ?Subroutine1
       7  ?Subroutine2
       3  ?Subroutine3
       8  ?Subroutine4
      68  MT_TransportAlloc
     108  MT_TransportSend
     235  npInit
      11  npSpiPollCallback
      20  npSpiReadyCallback
       2  npTxQueue
      47  npUartCback
       2  npUartTxCnt
       2  npUartTxMsg
       2  pMsg
       1  znpCfg0
       1  znpCfg1
     390  znpEventLoop
      17  znpInit
      48  -- Other

 
 932 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
  10 bytes in segment XDATA_Z
 
  48 bytes of CODE     memory
 932 bytes of HUGECODE memory
  10 bytes of XDATA    memory

Errors: none
Warnings: none
